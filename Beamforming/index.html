<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Beamforming</title>
  <x-claris-tagview mode="minimal"></x-claris-tagview>
</head>
<body>
<h1>
<center><font size="+2"><b>What Is
Beamforming?<br>
</b></font>
<hr style="width: 100%; height: 2px;"><a href="http://FindSabrina.org/"><img
 style="border: 0px solid ; width: 728px; height: 90px;"
 alt="FindSabrina.org"
 src="http://findsabrina.org/posters/BannerBig.gif"></a><br>
</center>
</h1>
<div style="text-align: center;">
<span style="font-weight: bold;">My daughter, Sabrina, has been
abducted. Please help me to find her by visiting </span><a
 style="font-weight: bold;" href="http://FindSabrina.org/">FindSabrina.org</a><span
 style="font-weight: bold;">.<br>
</span>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><br>
</span></div>
<blockquote>A beamformer is a spatial filter that operates on the
output of an array of sensors in order to enhance the amplitude of a
coherent wavefront relative to background noise and directional
interference. The figure below shows a curved array of hydrophone
sensors, or staves. Each sensor (red circle) is located at an (x,y)
coordinate as shown. These sensors are pointed in known directions
(blue arrows), and we wish to form beams which point in chosen
directions (green arrows). The "pointing direction" is called the
Maximum Response Angle (MRA), and can be arbitrarily chosen for the
beams.</blockquote>
<center><img src="Graphics/Geometry.gif" width="400" height="300"
 align="bottom"></center>
<blockquote>The response of a given element is plotted on a polar
graph, where the angle is the offset from the MRA, and the radius is
the magnitude response (dB) in that direction. Element responses
(determined by the 3dB down point) are very wide -- in this example the
width is about 90 degrees.
  <center><img src="Graphics/ElemPolarResp.gif" width="400" height="300"
 align="bottom"></center>
  <p>The goal of beamforming is to sum multiple elements to achieve a
narrower response in a desired direction (the MRA). That way when we
hear a sound in a given beam, we know which direction it came from.
Real implementations introduce things such as nulls and sidelobes,
which we won't discuss here.</p>
  <center><img src="Graphics/BeamPolarResp.gif" width="400" height="300"
 align="bottom">
  <p><font size="+2"><b>&nbsp;</b></font></p>
  </center>
</blockquote>
<h1>
<center><font size="+2"><b>Implementing a
Beamformer</b></font></center>
</h1>
<blockquote>Time-domain beamforming is done by delaying and adding
shaded outputs from an array of transducers. The (optional) shading of
the sensor outputs is done to improve the spatial response
characteristics of the beam, and is roughly equivalent to "windowing"
in DSP theory. Each beam is formed by delaying and summing sensor
elements. The following block diagram shows how a single beam is formed
from N transducers, in an analog beamformer.
  <center><img src="Graphics/AnalogBeamformer.gif" width="269"
 height="164" align="bottom"></center>
  <p>The delay used for each sensor element is determined by array
geometry and the desired MRA. Projecting the elements onto a line which
is perpendicular to the beam's MRA gives a distance for each element.
This distance (divided by the speed of sound) gives the delay required
to form the beam at the desired MRA.</p>
  <center><img src="Graphics/BeamProjections.gif" width="400"
 height="300" align="bottom"></center>
  <p>Note that we did not use every sensor to calculate every beam.
Since our array is curved, each sensor contributes to each beam
differently. In the following plot, high responses are white and low
responses are black. If the element and the beam point in the same
direction, the response is high.</p>
  <center><img src="Graphics/ElemResponse.gif" width="400" height="300"
 align="bottom"></center>
  <p>It doesn't make sense to use elements which point in the wrong
direction. In the following plot, any element which is some fixed
threshold below its maximum is zeroed out. Now we're only using the
non-zero elements to form each beam. This step saves on processing,
with minimal beam degradation.</p>
  <center><img src="Graphics/ElemThreshResponse.gif" width="400"
 height="300" align="bottom">
  <p><font size="+2"><b>&nbsp;</b></font></p>
  </center>
</blockquote>
<h1>
<center><font size="+2"><b>Digital Interpolation
Beamforming</b></font></center>
</h1>
<blockquote>In a digital implementation, we sample these elements at a
rate just above the Nyquist criterion. Although this preserves the
frequency content of the signal, this does not give enough steering
delay resolution. Digital interpolation is performed, increasing the
steering-delay resolution by a factor of L. Now time delays are
quantized to integer sample delays.
  <center><img src="Graphics/DigitalBeamformer.gif" width="398"
 height="165" align="bottom"></center>
  <p>In this example we use unity shading, and simply interpolate
across two samples. As a result, all coefficient values are between
zero and one. The figure below plots these values, where white is one
and black is zero. Non-zero coefficients are extremely sparse, allowing
efficient implementation. Note that each "picture" contains the values
required to calculate one sample of one beam output.</p>
  <center><img src="Graphics/BeamCoeffs.gif" width="400" height="300"
 align="bottom">
  <p><font size="+2"><b>&nbsp;</b></font></p>
  </center>
</blockquote>
<h1>
<center><font size="+2"><b>Beamforming as a Sparse FIR
Filter</b></font></center>
</h1>
<blockquote>Modeling the beamformer as a FIR filter allows for a
simple, concise organization of the algorithm. For our model we use the
following parameters, with values from the example in parentheses:
  <ul>
    <li>T - the total number of elements in the array (80)</li>
    <li>D - the maximum sample delay due to array geometry (31)</li>
    <li>L - the length of the interpolation filter (2)</li>
    <li>B - the number of beams calculated (61)</li>
    <li>S - the number of staves (elements) used to calculate a beam
(50)</li>
  </ul>
  <p>If multiple samples of the entire sensor array are stored
contiguously in memory, then each beam's coefficients can be
represented by a FIR filter of length N = (D+L-1)T. Now the entire
beamforming operation (for one sample of B beams) can be represented by
a single operation:</p>
  <center><img src="Graphics/operation.gif" width="427" height="102"
 align="bottom"></center>
  <p>The FIR filter length, N, can be extremely long -- in our example
it is 2560. However, the number of non-zero coefficients is only 100,
for a sparsity of 96%. As a result, 6100 multiply-accumulates (MACs)
are required per sample. At high-frequency sonar sample rates, we are
approaching one billion MACs per second.</p>
</blockquote>
<center><img src="Graphics/formulas.gif" width="359" height="113"
 align="bottom">
<hr></center>
<blockquote>
  <blockquote><font size="+1">For additional information</font>:</blockquote>
  <ul>
    <li>R. G. Pridham and R. A. Mucci, "A Novel Approach to Digital
Beamforming." <i>Journal of the Acoustical Society of America</i>,
vol. 63, no. 2, pp. 425-434, Feb. 1978.</li>
    <li>R. G. Pridham and R. A. Mucci, "Digital Interpolation
Beamforming for Low-Pass and Bandpass Signals." <i>Proceedings of the
IEEE</i>, vol. 67, no. 6, pp. 904-919, June 1979.</li>
    <li>R. A. Mucci, "A Comparison of Efficient Beamforming
Algorithms." <i>IEEE Transactions on Acoustics, Speech, and Signal
Processing</i>, vol. ASSP-32, no. 3, 548-558, June 1984.</li>
    <li>D. E. Dudgeon and R. M. Mersereau, "<a
 href="http://www.amazon.com/exec/obidos/tg/detail/-/0136049591/qid=1094058263/sr=8-1/ref=sr_8_xs_ap_i1_xgl14/102-7546612-7799323?v=glance&amp;s=books&amp;n=507846">Multidimensional
Digital Signal Processing</a>." Prentice Hall, 1983.<br>
    </li>
  </ul>
</blockquote>
<center>
<hr>
</center>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-13167684-1', 'bitbucket.org');
  ga('send', 'pageview');
</script>

</body>
</html>
