<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta name="generator" content="HTML Tidy for Mac OS X (vers 14 February 2006), see www.w3.org">
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>D4R Algorithm</title>
</head>
<body>
  <h3 style="text-align: center;">D4R Algorithm examples</h3><br>
  D4R is the distributed dynmaic deadlock detection and resolution algorithm. It is used to detect deadlock for bounded scheduling of PN (and CPN). Here, we provide some examples of the D4R algorithm.<br>
  <br>
  A paper describing the algorithm has been submitted to ICASSP 2007. The following two figures show the algorithm state variables at each node, and the algorithm state transitions.<br>
  <div style="text-align: center;">
    <br>
    <table style="text-align: left; width: 100%;" border="1" cellspacing="2" cellpadding="2">
      <tbody>
        <tr>
          <td style="text-align: center; vertical-align: middle;"><img src="SingleNode.png" alt=""></td>
          <td style="vertical-align: top; text-align: center;"><img src="StateTransitions.png" alt=""></td>
        </tr>
      </tbody>
    </table><br>
    <div style="text-align: left;">
      The first example is simple, but important -- the algorithm detects a deadlock for the most basic of cases. Node A continually tries to write 2 samples to queue Q, and node B continually tries to read 2 samples from Q. Q starts with a capacity of only 1. We know that until Q has a capacity of 2, A cannot write the 2 tokens. This example shows that the D4R algorithm detects that Q is too small, and causing an artificial deadlock.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="1" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: center;"><img style="width: 335px; height: 165px;" src="Ex1.gif" alt=""></td>
            <td style="vertical-align: middle; text-align: center;">Node A() { while (true) Q.put(2); }<br>
            <br>
            Node B() { while (true) Q.get(2); }<br></td>
          </tr>
        </tbody>
      </table><br>
      Note that this is not the only possible order of node executions, but that all orders will eventually lead to Q being lengthened.<br>
      <br>
      The second example is more complicated, and illustrates an artificial deadlock containing 3 nodes. Queue Q must grow to size 2 before the program can function normally. Again, this example demonstrates that this problem is detected and resolved.<br>
      <br>
      <table style="text-align: left; width: 100%;" border="1" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; text-align: center;"><img style="width: 345px; height: 295px;" src="Ex2.gif" alt=""><br></td>
            <td style="text-align: center; vertical-align: middle;">Node A() {while (true) { Q.put(2); Q.put(1); }}<br>
            <br>
            Node B() {while (true) { P.get(1); R.put(1); }}<br>
            <br>
            Node C() {while (true) { R.get(1); Q.get(2); }}<br></td>
          </tr>
        </tbody>
      </table><br>
      Again, the nodes could have executed in many different orders -- this order is one possible execution order. Note that step 6, node C knows that a deadlock exists, however the culpable queue is not located until step 7.<br>
      <br>
      <div style="text-align: center;">
        <a href="../CPN">Return&nbsp; to CPN page</a><br>
      </div>
    </div>
  </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-13167684-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
